DefaultMQProducer 相当于一个config builder对象

DefaultMQProducerImpl 实际的producer操作

MQClientManager 管理 MQClientInstance

MQClientInstance 核心类{
	pullMessageService = PullMessageService 干嘛的
	rebalanceService = RebalanceService     干嘛的
	consumerStatsManager = ConsumerStatsManager 干嘛的

	// 方法
	this.startScheduledTask();  里面的定时任务都是干嘛的
}

MQClientAPIImpl {
	remotingClient = NettyRemotingClient {
		processorTable 干嘛的
	}
	clientRemotingProcessor = ClientRemotingProcessor干嘛的
}

producerTable{

group:   DefaultMQProducerImpl{
			topicPublishInfoTable: {
				TBW102: new TopicPublishInfo()
			}	
		}
}



消费者集群模式不均摊消息问题??? ???
消费者向slave发送请求, 如何处理??? ???



AllocateMapedFileService 创建MapedFile

消费者
{
MessageQueue, ProcessQueue(具体做什么的)


}


RequestCode.CONSUMER_SEND_MSG_BACK


broker {
CommitLog

MapedFileQueue


FlushRealTimeService  定时去刷新CommitLog 文件

DefaultMessageStore


CommitLog.putMessage 为主要接收消息方法
	MapedFileQueue.getLastMapedFile
	MapedFile.appendMessage
	DefaultMessageStore.putDispatchRequest(DispatchRequest)

}





响应消息为什么使用: FileRegion进行响应??? ???














producer {

DefaultMQProducer  extends  ClientConfig 相当于一个build的config对象

消费者定时去更新消费进度和broker PullMessageProcessor正确响应消息后都调用同一个方法进行消费进度更新{
	要保证消费者的请求更新和broker的更新offset一致
	目前没有做一致性的校验
}


NettyRemotingClient.start 定时检查超时响应请求



entity: {
	TopicRouteData  topic信息

	ConsumerGroupInfo 消费者信息

	SubscriptionGroupConfig  订阅队列信息


	SubscriptionData 订阅信息

	ProcessQueue 拉取的消息处理

}


flow: {
	1. create DefaultMQProducerImpl  implements MQProducerInner{
			1.1 创建 MQClientInstance {
			
			}
		
			1.2 start MQClientInstance {
			
			
			}

			1.3 {
				发送心跳

			}

		}
}

}






